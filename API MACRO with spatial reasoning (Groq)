import FreeCAD as App
import FreeCADGui as Gui
from PySide import QtGui, QtCore
import requests
import json
import traceback
import ssl
import urllib3

# Disable SSL warnings - use with caution
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Constants
DEFAULT_MODEL = "llama3-70b-8192"
API_ENDPOINT = "https://api.groq.com/openai/v1/chat/completions"

class LLMToCADDialog(QtGui.QDialog):
    def __init__(self):
        super(LLMToCADDialog, self).__init__()
        self.setWindowTitle("Groq CAD Generator")
        self.resize(700, 650)
        self.setup_ui()
        
    def setup_ui(self):
        # Main layout
        layout = QtGui.QVBoxLayout(self)
        
        # API Key section
        api_layout = QtGui.QHBoxLayout()
        api_layout.addWidget(QtGui.QLabel("Groq API Key:"))
        self.api_key_input = QtGui.QLineEdit()
        self.api_key_input.setEchoMode(QtGui.QLineEdit.Password)
        self.api_key_input.setPlaceholderText("Enter your Groq API key")
        api_layout.addWidget(self.api_key_input)
        layout.addLayout(api_layout)
        
        # Model selection
        model_layout = QtGui.QHBoxLayout()
        model_layout.addWidget(QtGui.QLabel("Groq Model:"))
        self.model_selector = QtGui.QComboBox()
        self.model_selector.addItems([
            "llama3-70b-8192",
            "llama3-8b-8192",
            "mixtral-8x7b-32768",
            "gemma-7b-it"
        ])
        self.model_selector.setCurrentIndex(0)  # Default to llama3-70b
        model_layout.addWidget(self.model_selector)
        layout.addLayout(model_layout)
        
        # Description section
        layout.addWidget(QtGui.QLabel("CAD Description:"))
        self.description_input = QtGui.QTextEdit()
        self.description_input.setPlaceholderText("Describe what you want to create in detail...")
        layout.addWidget(self.description_input)
        
        # User-defined spatial parameters section
        param_group = QtGui.QGroupBox("Custom Spatial Parameters (Optional)")
        param_group_layout = QtGui.QVBoxLayout(param_group)
        
        # Container for parameters
        self.param_container = QtGui.QWidget()
        self.param_layout = QtGui.QVBoxLayout(self.param_container)
        self.param_layout.setContentsMargins(0, 0, 0, 0)
        
        # Initial parameter rows
        self.param_rows = []
        self.add_param_row()
        
        # Add parameter button
        param_btn_layout = QtGui.QHBoxLayout()
        add_param_btn = QtGui.QPushButton("Add Parameter")
        add_param_btn.clicked.connect(self.add_param_row)
        param_btn_layout.addWidget(add_param_btn)
        param_btn_layout.addStretch()
        self.param_layout.addLayout(param_btn_layout)
        
        # Add scrollable area for parameters
        scroll_area = QtGui.QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setWidget(self.param_container)
        scroll_area.setMaximumHeight(120)
        param_group_layout.addWidget(scroll_area)
        layout.addWidget(param_group)
        
        # LLM Spatial Reasoning
        self.spatial_reasoning_group = QtGui.QGroupBox("AI Spatial Reasoning")
        spatial_reasoning_layout = QtGui.QVBoxLayout(self.spatial_reasoning_group)
        
        reasoning_options = QtGui.QHBoxLayout()
        self.spatial_reasoning_checkbox = QtGui.QCheckBox("Enable AI Spatial Reasoning")
        self.spatial_reasoning_checkbox.setChecked(True)
        reasoning_options.addWidget(self.spatial_reasoning_checkbox)
        
        self.show_reasoning_checkbox = QtGui.QCheckBox("Show Reasoning")
        self.show_reasoning_checkbox.setChecked(False)
        reasoning_options.addWidget(self.show_reasoning_checkbox)
        reasoning_options.addStretch()
        spatial_reasoning_layout.addLayout(reasoning_options)
        
        self.spatial_reasoning_output = QtGui.QTextEdit()
        self.spatial_reasoning_output.setReadOnly(True)
        self.spatial_reasoning_output.setPlaceholderText("AI spatial reasoning will appear here when generation starts...")
        self.spatial_reasoning_output.setMaximumHeight(100)
        self.spatial_reasoning_output.setVisible(False)
        spatial_reasoning_layout.addWidget(self.spatial_reasoning_output)
        
        layout.addWidget(self.spatial_reasoning_group)
        
        # Connect show reasoning checkbox to visibility
        self.show_reasoning_checkbox.stateChanged.connect(
            lambda: self.spatial_reasoning_output.setVisible(self.show_reasoning_checkbox.isChecked())
        )
        
        # Buttons
        button_layout = QtGui.QHBoxLayout()
        self.generate_button = QtGui.QPushButton("Generate CAD Model")
        self.generate_button.clicked.connect(self.generate_model)
        button_layout.addWidget(self.generate_button)
        
        self.debug_checkbox = QtGui.QCheckBox("Enable Debug Mode")
        button_layout.addWidget(self.debug_checkbox)
        
        self.close_button = QtGui.QPushButton("Close")
        self.close_button.clicked.connect(self.reject)
        button_layout.addWidget(self.close_button)
        layout.addLayout(button_layout)
        
        # Output log
        layout.addWidget(QtGui.QLabel("Output:"))
        self.output_log = QtGui.QTextEdit()
        self.output_log.setReadOnly(True)
        layout.addWidget(self.output_log)
    
    def add_param_row(self):
        row_layout = QtGui.QHBoxLayout()
        
        # Parameter name
        param_name = QtGui.QLineEdit()
        param_name.setPlaceholderText("Parameter name (e.g., width)")
        row_layout.addWidget(param_name)
        
        # Parameter value
        param_value = QtGui.QLineEdit()
        param_value.setPlaceholderText("Value (e.g., 100mm)")
        row_layout.addWidget(param_value)
        
        # Remove button
        remove_btn = QtGui.QPushButton("X")
        remove_btn.setMaximumWidth(30)
        remove_btn.clicked.connect(lambda: self.remove_param_row(row_widget))
        row_layout.addWidget(remove_btn)
        
        # Create a container widget for this row
        row_widget = QtGui.QWidget()
        row_widget.setLayout(row_layout)
        
        # Insert the new row before the "Add Parameter" button
        self.param_layout.insertWidget(len(self.param_rows), row_widget)
        
        # Store references to widgets for later retrieval
        self.param_rows.append({
            "widget": row_widget,
            "name": param_name,
            "value": param_value
        })
    
    def remove_param_row(self, row_widget):
        # Find the row in our list
        for i, row in enumerate(self.param_rows):
            if row["widget"] == row_widget:
                # Remove from layout and delete
                self.param_layout.removeWidget(row_widget)
                row_widget.deleteLater()
                # Remove from our list
                self.param_rows.pop(i)
                break
    
    def get_spatial_parameters(self) -> dict:
        parameters = {}
        for row in self.param_rows:
            name = row["name"].text().strip()
            value = row["value"].text().strip()
            if name and value:
                parameters[name] = value
        return parameters
    
    def generate_model(self):
        api_key = self.api_key_input.text().strip()
        description = self.description_input.toPlainText().strip()
        
        if not api_key:
            self.output_log.append("Error: API key is required")
            return
            
        if not description:
            self.output_log.append("Error: Please provide a description")
            return
        
        try:
            # Get user-defined spatial parameters
            user_params = self.get_spatial_parameters()
            spatial_reasoning = None
            
            # Generate spatial reasoning if enabled
            if self.spatial_reasoning_checkbox.isChecked():
                self.output_log.append("Generating spatial reasoning...")
                spatial_reasoning = self.generate_spatial_reasoning(api_key, description, user_params)
                
                if not spatial_reasoning:
                    self.output_log.append("Warning: Failed to generate spatial reasoning. Continuing without it.")
                else:
                    # Display reasoning if requested
                    if self.show_reasoning_checkbox.isChecked():
                        self.spatial_reasoning_output.setVisible(True)
                        self.spatial_reasoning_output.setText(spatial_reasoning)
                    self.output_log.append("Spatial reasoning completed.")
            
            # Generate CAD code
            self.output_log.append("Sending request to Groq for CAD code generation...")
            code = self.get_code_from_groq(api_key, description, user_params, spatial_reasoning)
            
            if code:
                self.output_log.append("Code generated. Executing in FreeCAD...")
                
                if self.debug_checkbox.isChecked():
                    success, message = self.execute_code_with_debug(code, user_params, spatial_reasoning)
                else:
                    success, message = self.execute_code(code)
                    
                if success:
                    self.output_log.append("Success: " + message)
                else:
                    self.output_log.append("Error: " + message)
                    self.output_log.append("Generated code:")
                    self.output_log.append(code)
            else:
                self.output_log.append("Failed to generate code from Groq")
        except Exception as e:
            self.output_log.append(f"Error: {str(e)}")
            self.output_log.append(traceback.format_exc())
    
    def generate_spatial_reasoning(self, api_key: str, description: str, user_params: dict = None) -> str:
        """Generate logical spatial relationships for the described object"""
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}"
        }
        
        # Construct user parameters text if available
        user_params_text = ""
        if user_params and len(user_params) > 0:
            user_params_text = "User-defined parameters:\n"
            for name, value in user_params.items():
                user_params_text += f"- {name}: {value}\n"
        
        system_prompt = """You are a CAD engineering assistant with extensive knowledge of 3D modeling and real-world objects.
Your task is to analyze a description and provide detailed spatial reasoning about how components should be logically arranged.
Focus on identifying key components and their proper spatial relationships."""
        
        user_prompt = f"""Analyze this object description and provide detailed spatial reasoning:

DESCRIPTION:
{description}

{user_params_text}

Instructions:
1. Identify the main object and all its key components
2. For each component, determine:
   - Its proper position relative to other components
   - Its proper orientation (which way is up, front, etc.)
   - Any logical constraints (e.g., legs must touch the ground)
   - Important dimensions and their relationships (e.g., legs should be equal height)
3. Provide explicit coordinates when helpful (use a logical origin point)
4. Identify any symmetries that should be maintained
5. Note any functional requirements that affect positioning (e.g., drawer must have clearance to open)

Provide your analysis as a structured list of spatial guidelines and constraints.
Focus ONLY on the spatial relationships, positioning, and constraints."""
        
        model = self.model_selector.currentText()
        
        data = {
            "model": model,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "temperature": 0.1,
            "max_tokens": 2000
        }
        
        try:
            # Setting verify=False to bypass SSL verification - use with caution
            response = requests.post(
                API_ENDPOINT,
                headers=headers,
                json=data,
                verify=False,
                timeout=40
            )
            
            if response.status_code != 200:
                self.output_log.append(f"API Response Status: {response.status_code}")
                self.output_log.append(f"API Response Content: {response.text}")
                return None
            
            result = response.json()
            reasoning = result["choices"][0]["message"]["content"]
            
            return reasoning.strip()
            
        except Exception as e:
            self.output_log.append(f"Spatial reasoning error: {str(e)}")
            return None
    
    def get_code_from_groq(self, api_key: str, description: str, user_params: dict = None, spatial_reasoning: str = None) -> str:
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}"
        }
        
        system_prompt = """You are a CAD assistant that converts descriptions into FreeCAD Python code. 
Return ONLY executable Python code with no explanations or markdown formatting. 
The code should create the specified 3D model in FreeCAD with precise spatial positioning of all components."""
        
        # Construct user parameters text if available
        user_params_text = ""
        if user_params and len(user_params) > 0:
            user_params_text = "User Parameters:\n"
            for name, value in user_params.items():
                user_params_text += f"- {name}: {value}\n"
        
        # Include spatial reasoning if available
        spatial_reasoning_text = ""
        if spatial_reasoning:
            spatial_reasoning_text = f"""Spatial Reasoning Analysis:
{spatial_reasoning}

Follow ALL the spatial relationships and component positioning guidelines above when creating the CAD model."""
        
        user_prompt = f"""Create FreeCAD Python code for: {description}
        
{user_params_text}

{spatial_reasoning_text}

The code must:
1. Import necessary FreeCAD modules
2. Create a new document if needed
3. Create the 3D geometry described
4. Position all components correctly according to the spatial reasoning guidelines
5. Use parametric modeling when appropriate
6. Set dimensions according to provided parameters
7. Use reasonable dimensions for parameters not explicitly provided
8. Add proper colors and appearance
9. Ensure all components have logical real-world positioning (e.g., table legs must be positioned at corners and support the table top)
10. Be complete and ready to execute

Ensure correct, logical spatial positioning of all components.
Return only the Python code with no explanations or markdown."""
        
        model = self.model_selector.currentText()
        
        data = {
            "model": model,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "temperature": 0.2,
            "max_tokens": 4000
        }
        
        try:
            # Setting verify=False to bypass SSL verification - use with caution
            response = requests.post(
                API_ENDPOINT,
                headers=headers,
                json=data,
                verify=False,
                timeout=60  # Increased timeout
            )
            
            if response.status_code != 200:
                self.output_log.append(f"API Response Status: {response.status_code}")
                self.output_log.append(f"API Response Content: {response.text}")
                raise Exception(f"API error: {response.text}")
            
            result = response.json()
            code = result["choices"][0]["message"]["content"]
            
            # Remove markdown code blocks if present
            if code.startswith("```python"):
                code = code.replace("```python", "", 1)
                if code.endswith("```"):
                    code = code[:-3]
            
            return code.strip()
            
        except Exception as e:
            self.output_log.append(f"Request error details: {str(e)}")
            raise
    
    def execute_code(self, code: str) -> tuple[bool, str]:
        try:
            # Create a new document if none exists
            if App.ActiveDocument is None:
                App.newDocument("GroqGenerated")
            
            # Execute the code
            exec(code)
            
            # Recompute the document
            App.ActiveDocument.recompute()
            Gui.SendMsgToActiveView("ViewFit")
            
            return True, "Model created successfully"
        except Exception as e:
            return False, f"Failed to execute code: {str(e)}"

    def execute_code_with_debug(self, code: str, user_params: dict = None, spatial_reasoning: str = None) -> tuple[bool, str]:
        """Execute code with debugging and error feedback"""
        # Store original code for reference
        original_code = code
        
        # Initialize debug information
        debug_info = {
            "attempt": 0,
            "errors": [],
            "object_state": [],
            "execution_log": []
        }
        
        max_attempts = 3  # Maximum number of retry attempts
        
        for attempt in range(max_attempts):
            debug_info["attempt"] = attempt + 1
            
            try:
                # Prepare execution environment
                if App.ActiveDocument is None:
                    App.newDocument("GroqGenerated")
                elif attempt > 0:  # Clear previous attempt if this is a retry
                    doc_name = App.ActiveDocument.Name
                    App.closeDocument(doc_name)
                    App.newDocument("GroqGenerated")
                
                # Create execution tracking
                execution_log = []
                
                # Split code into lines for line-by-line execution
                code_lines = code.split('\n')
                line_num = 0
                
                # Execute code line by line
                while line_num < len(code_lines):
                    current_line = code_lines[line_num].strip()
                    
                    # Skip empty lines and comments
                    if not current_line or current_line.startswith('#'):
                        line_num += 1
                        continue
                    
                    # Find complete statements (handling multi-line statements)
                    statement = current_line
                    while not self.is_complete_statement(statement) and line_num < len(code_lines) - 1:
                        line_num += 1
                        statement += '\n' + code_lines[line_num].strip()
                    
                    # Log the statement being executed
                    execution_log.append(f"Executing: {statement}")
                    
                    try:
                        # Execute the individual statement
                        exec(statement)
                        
                        # Capture object state after significant operations
                        if any(keyword in statement for keyword in ['makeBox', 'makeCylinder', 'extrude', 'cut', 'fuse']):
                            self.capture_object_state(debug_info)
                        
                    except Exception as e:
                        # Capture the specific error
                        error_info = {
                            "line_num": line_num + 1,
                            "code": statement,
                            "error_type": type(e).__name__,
                            "error_msg": str(e),
                            "traceback": traceback.format_exc()
                        }
                        debug_info["errors"].append(error_info)
                        
                        # Log error
                        execution_log.append(f"Error at line {line_num + 1}: {type(e).__name__}: {str(e)}")
                        
                        # Break execution at first error
                        break
                    
                    line_num += 1
                
                # Store execution log
                debug_info["execution_log"] = execution_log
                
                # If we got here without breaking, execution was successful
                if not debug_info["errors"]:
                    # Final recompute
                    App.ActiveDocument.recompute()
                    Gui.SendMsgToActiveView("ViewFit")
                    return True, "Model created successfully"
                
                # If we had errors, try to fix them
                if attempt < max_attempts - 1:  # Don't try to fix on the last attempt
                    # Send debug info to Groq for correction
                    code = self.get_fixed_code_from_groq(original_code, debug_info, user_params, spatial_reasoning)
                    
                    # Clear errors for next attempt
                    debug_info["errors"] = []
                
            except Exception as e:
                # Catch any other exceptions
                debug_info["errors"].append({
                    "error_type": type(e).__name__,
                    "error_msg": str(e),
                    "traceback": traceback.format_exc()
                })
        
        # If we got here, all attempts failed
        error_summary = self.format_debug_info(debug_info)
        return False, f"Failed to create model after {max_attempts} attempts.\n\n{error_summary}"

    def is_complete_statement(self, code: str) -> bool:
        """Check if a code snippet is a complete Python statement"""
        try:
            compile(code, '<string>', 'exec')
            return True
        except SyntaxError as e:
            if 'unexpected EOF' in str(e):
                return False
            return True  # Other syntax errors mean it's complete but invalid

    def capture_object_state(self, debug_info: dict):
        """Capture the current state of objects in the document"""
        if not App.ActiveDocument:
            return
        
        import time
        objects_info = []
        for obj in App.ActiveDocument.Objects:
            try:
                obj_info = {
                    "name": obj.Name,
                    "type": obj.TypeId,
                    "valid": obj.isValid()
                }
                
                # Capture additional properties based on object type
                if hasattr(obj, "Shape"):
                    obj_info["has_shape"] = True
                    if obj.Shape:
                        obj_info["shape_valid"] = obj.Shape.isValid()
                        obj_info["shape_type"] = obj.Shape.ShapeType
                    else:
                        obj_info["has_shape"] = False
                
                objects_info.append(obj_info)
            except:
                # Skip objects that cause errors when examined
                pass
        
        debug_info["object_state"].append({
            "timestamp": time.time(),
            "objects": objects_info
        })

    def get_fixed_code_from_groq(self, original_code: str, debug_info: dict, user_params: dict = None, spatial_reasoning: str = None) -> str:
        """Send debug info to Groq and get fixed code"""
        # Format debug info for Groq
        error_context = self.format_debug_info(debug_info)
        
        # Format user parameters if available
        user_params_text = ""
        if user_params and len(user_params) > 0:
            user_params_text = "USER PARAMETERS:\n"
            for name, value in user_params.items():
                user_params_text += f"- {name}: {value}\n"
                
        # Include spatial reasoning if available
        spatial_reasoning_text = ""
        if spatial_reasoning:
            spatial_reasoning_text = f"""SPATIAL REASONING:
{spatial_reasoning}

Follow ALL the spatial relationships and component positioning guidelines above when fixing the CAD model."""
        
        # Create prompt for Groq
        prompt = f"""I tried to create a FreeCAD model with the following Python code, but encountered errors:

ORIGINAL CODE:
```python
{original_code}
```

{user_params_text}
{spatial_reasoning_text}

EXECUTION DETAILS:
{error_context}

Please fix the code to resolve these errors. Return only the complete corrected code with no explanations or markdown formatting.
The code must:
1. Be valid Python code that works with FreeCAD's API
2. Fix all the execution errors shown above
3. Follow the spatial reasoning guidelines to ensure components have logical placement
4. Respect the user parameters specified above
5. Ensure all parts of the model are positioned in realistic, functional arrangements"""

        # Send to Groq
        fixed_code = self.send_to_groq(prompt)
        
        # Log the correction attempt
        self.output_log.append(f"Attempt {debug_info['attempt']} failed. Trying with corrected code...")
        
        return fixed_code

    def format_debug_info(self, debug_info: dict) -> str:
        """Format debug info into a readable string for UI display and Groq input"""
        result = []
        
        # Add error information
        if debug_info["errors"]:
            result.append("ERRORS:")
            for i, error in enumerate(debug_info["errors"]):
                result.append(f"Error {i+1}:")
                if "line_num" in error:
                    result.append(f"- Line number: {error['line_num']}")
                if "code" in error:
                    result.append(f"- Code: {error['code']}")
                result.append(f"- Type: {error['error_type']}")
                result.append(f"- Message: {error['error_msg']}")
                # Include only the relevant parts of the traceback
                if "traceback" in error:
                    tb_lines = error["traceback"].split("\n")
                    filtered_tb = [l for l in tb_lines if "File" in l and "<string>" in l]
                    if filtered_tb:
                        result.append("- Traceback:")
                        result.extend([f"  {l}" for l in filtered_tb])
                result.append("")
        
        # Add execution log (last 10 entries to keep it manageable)
        if debug_info["execution_log"]:
            result.append("EXECUTION LOG (last 10 operations):")
            for log in debug_info["execution_log"][-10:]:
                result.append(f"- {log}")
            result.append("")
        
        # Add object state info from the last capture
        if debug_info["object_state"]:
            last_state = debug_info["object_state"][-1]
            result.append("OBJECT STATE:")
            for obj in last_state["objects"]:
                obj_status = "Valid" if obj.get("valid", False) else "Invalid"
                result.append(f"- {obj['name']} ({obj['type']}): {obj_status}")
                if "has_shape" in obj:
                    if obj["has_shape"]:
                        shape_status = "Valid" if obj.get("shape_valid", False) else "Invalid"
                        result.append(f"  Shape: {obj.get('shape_type', 'Unknown')} ({shape_status})")
                    else:
                        result.append(f"  Shape: None")
        
        return "\n".join(result)

    def send_to_groq(self, prompt: str) -> str:
        """Send a prompt to the Groq API and get a response"""
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.api_key_input.text()}"
        }
        
        model = self.model_selector.currentText()
        
        data = {
            "model": model,
            "messages": [
                {"role": "system", "content": "You are a CAD code debugging assistant. Fix FreeCAD Python code based on error information."},
                {"role": "user", "content": prompt}
            ],
            "temperature": 0.2,
            "max_tokens": 4000
        }
        
        try:
            # Setting verify=False to bypass SSL verification - use with caution
            response = requests.post(
                API_ENDPOINT,
                headers=headers,
                json=data,
                verify=False,
                timeout=60  # Increased timeout
            )
            
            if response.status_code != 200:
                self.output_log.append(f"API Response Status: {response.status_code}")
                self.output_log.append(f"API Response Content: {response.text}")
                raise Exception(f"API error: {response.text}")
            
            result = response.json()
            code = result["choices"][0]["message"]["content"]
            
            # Remove markdown code blocks if present
            if code.startswith("```python"):
                code = code.replace("```python", "", 1)
                if code.endswith("```"):
                    code = code[:-3]
            
            return code.strip()
            
        except Exception as e:
            self.output_log.append(f"Request error details: {str(e)}")
            raise

# Show the dialog when the macro is run
dialog = LLMToCADDialog()
dialog.exec_()
