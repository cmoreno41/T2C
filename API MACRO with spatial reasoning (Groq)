import FreeCAD as App
import FreeCADGui as Gui
from PySide import QtGui, QtCore
import requests
import json
import traceback
import ssl
import urllib3

# Disable SSL warnings - use with caution
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Constants
DEFAULT_MODEL = "llama3-70b-8192"
API_ENDPOINT = "https://api.groq.com/openai/v1/chat/completions"

class LLMToCADDialog(QtGui.QDialog):
    def __init__(self):
        super(LLMToCADDialog, self).__init__()
        self.setWindowTitle("Groq CAD Generator")
        self.resize(700, 650)
        self.setup_ui()
        
    def setup_ui(self):
        # Main layout
        layout = QtGui.QVBoxLayout(self)
        
        # API Key section
        api_layout = QtGui.QHBoxLayout()
        api_layout.addWidget(QtGui.QLabel("Groq API Key:"))
        self.api_key_input = QtGui.QLineEdit()
        self.api_key_input.setEchoMode(QtGui.QLineEdit.Password)
        self.api_key_input.setPlaceholderText("Enter your Groq API key")
        api_layout.addWidget(self.api_key_input)
        layout.addLayout(api_layout)
        
        # Model selection
        model_layout = QtGui.QHBoxLayout()
        model_layout.addWidget(QtGui.QLabel("Groq Model:"))
        self.model_selector = QtGui.QComboBox()
        self.model_selector.addItems([
            "llama3-70b-8192",
            "llama3-8b-8192",
            "mixtral-8x7b-32768",
            "gemma-7b-it"
        ])
        self.model_selector.setCurrentIndex(0)  # Default to llama3-70b
        model_layout.addWidget(self.model_selector)
        layout.addLayout(model_layout)
        
        # Description section
        layout.addWidget(QtGui.QLabel("CAD Description:"))
        self.description_input = QtGui.QTextEdit()
        self.description_input.setPlaceholderText("Describe what you want to create in detail...")
        layout.addWidget(self.description_input)
        
        # User-defined spatial parameters section
        param_group = QtGui.QGroupBox("Custom Spatial Parameters (Optional)")
        param_group_layout = QtGui.QVBoxLayout(param_group)
        
        # Container for parameters
        self.param_container = QtGui.QWidget()
        self.param_layout = QtGui.QVBoxLayout(self.param_container)
        self.param_layout.setContentsMargins(0, 0, 0, 0)
        
        # Initial parameter rows
        self.param_rows = []
        self.add_param_row()
        
        # Add parameter button
        param_btn_layout = QtGui.QHBoxLayout()
        add_param_btn = QtGui.QPushButton("Add Parameter")
        add_param_btn.clicked.connect(self.add_param_row)
        param_btn_layout.addWidget(add_param_btn)
        param_btn_layout.addStretch()
        self.param_layout.addLayout(param_btn_layout)
        
        # Add scrollable area for parameters
        scroll_area = QtGui.QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setWidget(self.param_container)
        scroll_area.setMaximumHeight(120)
        param_group_layout.addWidget(scroll_area)
        layout.addWidget(param_group)
        
        # Advanced options section
        advanced_group = QtGui.QGroupBox("Advanced Options")
        advanced_layout = QtGui.QVBoxLayout(advanced_group)
        
        # LLM Spatial Reasoning
        reasoning_options = QtGui.QHBoxLayout()
        self.spatial_reasoning_checkbox = QtGui.QCheckBox("Enable AI Spatial Reasoning")
        self.spatial_reasoning_checkbox.setChecked(True)
        reasoning_options.addWidget(self.spatial_reasoning_checkbox)
        
        self.show_reasoning_checkbox = QtGui.QCheckBox("Show Reasoning")
        self.show_reasoning_checkbox.setChecked(False)
        reasoning_options.addWidget(self.show_reasoning_checkbox)
        
        self.component_plan_checkbox = QtGui.QCheckBox("Generate Component Plan")
        self.component_plan_checkbox.setChecked(True)
        reasoning_options.addWidget(self.component_plan_checkbox)
        
        reasoning_options.addStretch()
        advanced_layout.addLayout(reasoning_options)
        
        # Debug options
        debug_options = QtGui.QHBoxLayout()
        self.debug_checkbox = QtGui.QCheckBox("Debug Mode")
        debug_options.addWidget(self.debug_checkbox)
        
        self.visual_debug_checkbox = QtGui.QCheckBox("Visual Debug")
        self.visual_debug_checkbox.setChecked(True)
        debug_options.addWidget(self.visual_debug_checkbox)
        
        self.add_validation_checkbox = QtGui.QCheckBox("Add Validation Code")
        self.add_validation_checkbox.setChecked(True)
        debug_options.addWidget(self.add_validation_checkbox)
        
        debug_options.addStretch()
        advanced_layout.addLayout(debug_options)
        
        # Object type selection
        object_type_layout = QtGui.QHBoxLayout()
        object_type_layout.addWidget(QtGui.QLabel("Object Type:"))
        self.object_type_selector = QtGui.QComboBox()
        self.object_type_selector.addItems([
            "Auto-detect",
            "Table",
            "Chair",
            "Shelf",
            "Cabinet",
            "Desk",
            "Bed",
            "Other"
        ])
        self.object_type_selector.setCurrentIndex(0)  # Default to auto-detect
        object_type_layout.addWidget(self.object_type_selector)
        object_type_layout.addStretch()
        advanced_layout.addLayout(object_type_layout)
        
        layout.addWidget(advanced_group)
        
        # Spatial reasoning output
        self.spatial_reasoning_output = QtGui.QTextEdit()
        self.spatial_reasoning_output.setReadOnly(True)
        self.spatial_reasoning_output.setPlaceholderText("AI spatial reasoning will appear here when generation starts...")
        self.spatial_reasoning_output.setMaximumHeight(100)
        self.spatial_reasoning_output.setVisible(False)
        layout.addWidget(self.spatial_reasoning_output)
        
        # Connect show reasoning checkbox to visibility
        self.show_reasoning_checkbox.stateChanged.connect(
            lambda: self.spatial_reasoning_output.setVisible(self.show_reasoning_checkbox.isChecked())
        )
        
        # Buttons
        button_layout = QtGui.QHBoxLayout()
        self.generate_button = QtGui.QPushButton("Generate CAD Model")
        self.generate_button.clicked.connect(self.generate_model)
        button_layout.addWidget(self.generate_button)
        
        self.close_button = QtGui.QPushButton("Close")
        self.close_button.clicked.connect(self.reject)
        button_layout.addWidget(self.close_button)
        layout.addLayout(button_layout)
        
        # Output log
        layout.addWidget(QtGui.QLabel("Output:"))
        self.output_log = QtGui.QTextEdit()
        self.output_log.setReadOnly(True)
        layout.addWidget(self.output_log)
    
    def add_param_row(self):
        row_layout = QtGui.QHBoxLayout()
        
        # Parameter name
        param_name = QtGui.QLineEdit()
        param_name.setPlaceholderText("Parameter name (e.g., width)")
        row_layout.addWidget(param_name)
        
        # Parameter value
        param_value = QtGui.QLineEdit()
        param_value.setPlaceholderText("Value (e.g., 100mm)")
        row_layout.addWidget(param_value)
        
        # Remove button
        remove_btn = QtGui.QPushButton("X")
        remove_btn.setMaximumWidth(30)
        remove_btn.clicked.connect(lambda: self.remove_param_row(row_widget))
        row_layout.addWidget(remove_btn)
        
        # Create a container widget for this row
        row_widget = QtGui.QWidget()
        row_widget.setLayout(row_layout)
        
        # Insert the new row before the "Add Parameter" button
        self.param_layout.insertWidget(len(self.param_rows), row_widget)
        
        # Store references to widgets for later retrieval
        self.param_rows.append({
            "widget": row_widget,
            "name": param_name,
            "value": param_value
        })
    
    def remove_param_row(self, row_widget):
        # Find the row in our list
        for i, row in enumerate(self.param_rows):
            if row["widget"] == row_widget:
                # Remove from layout and delete
                self.param_layout.removeWidget(row_widget)
                row_widget.deleteLater()
                # Remove from our list
                self.param_rows.pop(i)
                break
    
    def get_spatial_parameters(self) -> dict:
        parameters = {}
        for row in self.param_rows:
            name = row["name"].text().strip()
            value = row["value"].text().strip()
            if name and value:
                parameters[name] = value
        return parameters
    
    def get_object_type(self, description: str) -> str:
        """Determine the object type either from selector or by analyzing description"""
        selected_type = self.object_type_selector.currentText()
        
        if selected_type != "Auto-detect":
            return selected_type.lower()
        
        # Simple keyword detection for auto-detection
        description_lower = description.lower()
        
        if any(word in description_lower for word in ["table", "dining", "coffee table"]):
            return "table"
        elif any(word in description_lower for word in ["chair", "stool"]):
            return "chair"
        elif any(word in description_lower for word in ["shelf", "bookshelf", "shelving"]):
            return "shelf"
        elif any(word in description_lower for word in ["cabinet", "dresser", "wardrobe"]):
            return "cabinet"
        elif any(word in description_lower for word in ["desk", "workstation"]):
            return "desk"
        elif any(word in description_lower for word in ["bed", "bedframe"]):
            return "bed"
        
        return "other"
    
    def generate_model(self):
        api_key = self.api_key_input.text().strip()
        description = self.description_input.toPlainText().strip()
        
        if not api_key:
            self.output_log.append("Error: API key is required")
            return
            
        if not description:
            self.output_log.append("Error: Please provide a description")
            return
        
        try:
            # Get user-defined spatial parameters
            user_params = self.get_spatial_parameters()
            
            # Determine object type
            object_type = self.get_object_type(description)
            self.output_log.append(f"Detected object type: {object_type}")
            
            spatial_reasoning = None
            component_plan = None
            
            # Generate spatial reasoning if enabled
            if self.spatial_reasoning_checkbox.isChecked():
                self.output_log.append("Generating spatial reasoning...")
                spatial_reasoning = self.generate_spatial_reasoning(api_key, description, object_type, user_params)
                
                if not spatial_reasoning:
                    self.output_log.append("Warning: Failed to generate spatial reasoning. Continuing without it.")
                else:
                    # Display reasoning if requested
                    if self.show_reasoning_checkbox.isChecked():
                        self.spatial_reasoning_output.setVisible(True)
                        self.spatial_reasoning_output.setText(spatial_reasoning)
                    self.output_log.append("Spatial reasoning completed.")
            
            # Generate component plan if enabled
            if self.component_plan_checkbox.isChecked() and spatial_reasoning:
                self.output_log.append("Generating component plan...")
                component_plan = self.generate_component_plan(api_key, description, object_type, spatial_reasoning, user_params)
                
                if not component_plan:
                    self.output_log.append("Warning: Failed to generate component plan. Continuing without it.")
                else:
                    self.output_log.append("Component plan completed.")
            
            # Generate CAD code
            self.output_log.append("Sending request to Groq for CAD code generation...")
            code = self.get_code_from_groq(api_key, description, object_type, user_params, spatial_reasoning, component_plan)
            
            if code:
                self.output_log.append("Code generated. Executing in FreeCAD...")
                
                if self.debug_checkbox.isChecked():
                    success, message = self.execute_code_with_debug(code, object_type, user_params, spatial_reasoning, component_plan)
                else:
                    success, message = self.execute_code(code)
                    
                if success:
                    self.output_log.append("Success: " + message)
                else:
                    self.output_log.append("Error: " + message)
                    self.output_log.append("Generated code:")
                    self.output_log.append(code)
            else:
                self.output_log.append("Failed to generate code from Groq")
        except Exception as e:
            self.output_log.append(f"Error: {str(e)}")
            self.output_log.append(traceback.format_exc())
    
    def generate_spatial_reasoning(self, api_key: str, description: str, object_type: str, user_params: dict = None) -> str:
        """Generate logical spatial relationships for the described object"""
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}"
        }
        
        # Construct user parameters text if available
        user_params_text = ""
        if user_params and len(user_params) > 0:
            user_params_text = "User-defined parameters:\n"
            for name, value in user_params.items():
                user_params_text += f"- {name}: {value}\n"
        
        system_prompt = """You are a CAD engineering assistant with extensive knowledge of 3D modeling and real-world objects.
Your task is to analyze a description and provide detailed spatial reasoning about how components should be logically arranged.
Focus on identifying key components and their proper spatial relationships.

VERY IMPORTANT: Define a CLEAR coordinate system where:
- The origin (0,0,0) is at the CENTER of the BOTTOM FACE of the main component (e.g., table top)
- Z-axis points upward (height)
- X-axis defines the length (typically longer dimension) 
- Y-axis defines the width (typically shorter dimension)
- All measurements must be explicitly defined in millimeters (mm)
- Use negative z-values for anything below the main component's bottom face
- Use absolute coordinates for all component positions"""
        
        # Add object-specific instructions
        object_specific = ""
        if object_type == "table":
            object_specific = """
For tables:
- Table top origin should be at (0,0,0) at the center of its bottom face
- Table top extends along +Z by its thickness
- Table legs should extend downward from z=0 to z=-table_height
- Legs should be positioned at the corners of the table
- Calculate exact coordinates for all four legs
- Dimensions should follow furniture standards:
  - Standard dining table height: 750mm
  - Standard coffee table height: 450mm
  - Standard console table height: 750-800mm
"""
        elif object_type == "chair":
            object_specific = """
For chairs:
- Seat origin should be at (0,0,0) at the center of its bottom face
- Seat extends along +Z by its thickness
- Legs should extend downward from z=0 to z=-seat_height
- Backrest should extend upward from the back edge of the seat
- Calculate exact coordinates for all legs and the backrest
- Dimensions should follow furniture standards:
  - Standard seat height: 450mm
  - Standard backrest height from floor: 800-950mm
"""
        
        user_prompt = f"""Analyze this object description and provide detailed spatial reasoning:

DESCRIPTION:
{description}

OBJECT TYPE: {object_type}

{user_params_text}

Instructions:
1. Identify the main object and all its key components
2. For each component, determine:
   - Its proper position using EXACT ABSOLUTE COORDINATES with the origin as specified
   - Its proper orientation (which way is up, front, etc.)
   - Any logical constraints (e.g., legs must touch the ground)
   - EXACT dimensions in millimeters (mm)
3. Provide explicit (x,y,z) coordinates for ALL components
4. Identify any symmetries that should be maintained
5. Note any functional requirements that affect positioning

Provide your analysis as a structured list of spatial guidelines and constraints.
Focus ONLY on the spatial relationships, positioning, and constraints."""

        if object_specific:
            user_prompt += f"\n\n{object_specific}"
        
        model = self.model_selector.currentText()
        
        data = {
            "model": model,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "temperature": 0.1,
            "max_tokens": 2000
        }
        
        try:
            # Setting verify=False to bypass SSL verification - use with caution
            response = requests.post(
                API_ENDPOINT,
                headers=headers,
                json=data,
                verify=False,
                timeout=40
            )
            
            if response.status_code != 200:
                self.output_log.append(f"API Response Status: {response.status_code}")
                self.output_log.append(f"API Response Content: {response.text}")
                return None
            
            result = response.json()
            reasoning = result["choices"][0]["message"]["content"]
            
            return reasoning.strip()
            
        except Exception as e:
            self.output_log.append(f"Spatial reasoning error: {str(e)}")
            return None
    
    def generate_component_plan(self, api_key: str, description: str, object_type: str, spatial_reasoning: str, user_params: dict = None) -> str:
        """Generate a specific component plan with exact coordinates and dimensions"""
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}"
        }
        
        # Construct user parameters text if available
        user_params_text = ""
        if user_params and len(user_params) > 0:
            user_params_text = "User-defined parameters:\n"
            for name, value in user_params.items():
                user_params_text += f"- {name}: {value}\n"
        
        system_prompt = """You are a CAD engineering assistant that specializes in creating precise component plans with exact measurements and coordinates.
Your task is to create a structured, detailed plan for implementing a 3D model in FreeCAD, based on spatial reasoning guidelines.
Focus on translating conceptual guidelines into precise numerical specifications that can be directly implemented in code."""
        
        # Add object-specific templates
        template = ""
        if object_type == "table":
            template = """
# TABLE COMPONENT PLAN
## Parameters
table_length = ? mm
table_width = ? mm
table_height = ? mm
table_top_thickness = ? mm
leg_width = ? mm
leg_depth = ? mm

## Coordinate System
Origin: Center of bottom face of table top
X-axis: Length direction
Y-axis: Width direction
Z-axis: Height (upward)

## Components
1. Table Top
   Position: (0, 0, table_top_thickness/2)
   Dimensions: table_length × table_width × table_top_thickness
   Shape: Box

2. Leg 1 (Front Left)
   Position: (-table_length/2 + leg_width/2, -table_width/2 + leg_depth/2, -table_height/2)
   Dimensions: leg_width × leg_depth × table_height
   Shape: Box

3. Leg 2 (Front Right)
   Position: (table_length/2 - leg_width/2, -table_width/2 + leg_depth/2, -table_height/2)
   Dimensions: leg_width × leg_depth × table_height
   Shape: Box

4. Leg 3 (Back Right)
   Position: (table_length/2 - leg_width/2, table_width/2 - leg_depth/2, -table_height/2)
   Dimensions: leg_width × leg_depth × table_height
   Shape: Box

5. Leg 4 (Back Left)
   Position: (-table_length/2 + leg_width/2, table_width/2 - leg_depth/2, -table_height/2)
   Dimensions: leg_width × leg_depth × table_height
   Shape: Box
"""
        elif object_type == "chair":
            template = """
# CHAIR COMPONENT PLAN
## Parameters
seat_length = ? mm
seat_width = ? mm
seat_height = ? mm
seat_thickness = ? mm
backrest_height = ? mm
backrest_thickness = ? mm
leg_width = ? mm

## Coordinate System
Origin: Center of bottom face of seat
X-axis: Length direction (front to back)
Y-axis: Width direction (side to side)
Z-axis: Height (upward)

## Components
1. Seat
   Position: (0, 0, seat_thickness/2)
   Dimensions: seat_length × seat_width × seat_thickness
   Shape: Box

2. Backrest
   Position: (-seat_length/2 + backrest_thickness/2, 0, (backrest_height/2) + seat_thickness)
   Dimensions: backrest_thickness × seat_width × backrest_height
   Shape: Box

3. Leg 1 (Front Left)
   Position: (seat_length/2 - leg_width/2, -seat_width/2 + leg_width/2, -seat_height/2)
   Dimensions: leg_width × leg_width × seat_height
   Shape: Box

4. Leg 2 (Front Right)
   Position: (seat_length/2 - leg_width/2, seat_width/2 - leg_width/2, -seat_height/2)
   Dimensions: leg_width × leg_width × seat_height
   Shape: Box
   
5. Leg 3 (Back Right)
   Position: (-seat_length/2 + leg_width/2, seat_width/2 - leg_width/2, -seat_height/2)
   Dimensions: leg_width × leg_width × seat_height
   Shape: Box
   
6. Leg 4 (Back Left)
   Position: (-seat_length/2 + leg_width/2, -seat_width/2 + leg_width/2, -seat_height/2)
   Dimensions: leg_width × leg_width × seat_height
   Shape: Box
"""
        
        user_prompt = f"""Create a detailed component plan for this object:

DESCRIPTION:
{description}

OBJECT TYPE: {object_type}

{user_params_text}

SPATIAL REASONING:
{spatial_reasoning}

Instructions:
1. Use the spatial reasoning provided to create a precise component-by-component plan
2. Ensure each component has:
   - EXACT position using (x, y, z) coordinates in millimeters
   - EXACT dimensions in millimeters
   - Precise geometric shape to use (Box, Cylinder, etc.)
3. Define all parameters with specific numerical values
4. Use ABSOLUTE coordinates matching the coordinate system in the spatial reasoning
5. Position components logically to maintain functional relationships
6. Include comments explaining positioning logic where helpful

Format your response as a structured plan that can be directly translated to FreeCAD code."""

        if template:
            user_prompt += f"\n\nUse this template as a guide, but fill in the exact values:\n{template}"
        
        model = self.model_selector.currentText()
        
        data = {
            "model": model,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "temperature": 0.1,
            "max_tokens": 3000
        }
        
        try:
            # Setting verify=False to bypass SSL verification - use with caution
            response = requests.post(
                API_ENDPOINT,
                headers=headers,
                json=data,
                verify=False,
                timeout=40
            )
            
            if response.status_code != 200:
                self.output_log.append(f"API Response Status: {response.status_code}")
                self.output_log.append(f"API Response Content: {response.text}")
                return None
            
            result = response.json()
            plan = result["choices"][0]["message"]["content"]
            
            return plan.strip()
            
        except Exception as e:
            self.output_log.append(f"Component plan error: {str(e)}")
            return None
    
    def get_code_from_groq(self, api_key: str, description: str, object_type: str, user_params: dict = None, spatial_reasoning: str = None, component_plan: str = None) -> str:
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}"
        }
        
        system_prompt = """You are a CAD assistant that converts descriptions into FreeCAD Python code. 
Return ONLY executable Python code with no explanations or markdown formatting. 
The code should create the specified 3D model in FreeCAD with precise spatial positioning of all components."""
        
        # Construct user parameters text if available
        user_params_text = ""
        if user_params and len(user_params) > 0:
            user_params_text = "User Parameters:\n"
            for name, value in user_params.items():
                user_params_text += f"- {name}: {value}\n"
        
        # Include spatial reasoning if available
        spatial_reasoning_text = ""
        if spatial_reasoning:
            spatial_reasoning_text = f"""Spatial Reasoning Analysis:
{spatial_reasoning}"""
        
        # Include component plan if available
        component_plan_text = ""
        if component_plan:
            component_plan_text = f"""Component Plan:
{component_plan}"""
        
        # Add object-specific instructions
        object_specific_instructions = ""
        if object_type == "table":
            object_specific_instructions = """
For tables, your code MUST:
1. Set the origin (0,0,0) at the CENTER of the BOTTOM FACE of the table top
2. Position the table top centered at (0, 0, table_top_thickness/2)
3. Position legs at the corners, extending from z=0 downward to the floor
4. Define all positions using ABSOLUTE coordinates (not relative/incremental)
5. Set standard dimensions if not specified:
   - Standard table height: 750mm
   - Standard top thickness: 30mm
   - Standard leg width: 50mm"""
        elif object_type == "chair":
            object_specific_instructions = """
For chairs, your code MUST:
1. Set the origin (0,0,0) at the CENTER of the BOTTOM FACE of the seat
2. Position the seat centered at (0, 0, seat_thickness/2)
3. Position legs at the corners, extending from z=0 downward to the floor
4. Position backrest at the rear edge of the seat, extending upward
5. Define all positions using ABSOLUTE coordinates (not relative/incremental)
6. Set standard dimensions if not specified:
   - Standard seat height: 450mm
   - Standard backrest height: 350mm above seat
   - Standard seat thickness: 30mm"""
        
        # Add validation code if requested
        validation_code = ""
        if self.add_validation_checkbox.isChecked():
            if object_type == "table":
                validation_code = """
# Add validation code to ensure proper positioning
def validate_table_positioning():
    doc = App.ActiveDocument
    table_top = None
    legs = []
    
    # Identify components
    for obj in doc.Objects:
        if hasattr(obj, "Label"):
            if "top" in obj.Label.lower():
                table_top = obj
            elif "leg" in obj.Label.lower():
                legs.append(obj)
    
    # Check table top positioning
    if table_top:
        bb = table_top.Shape.BoundBox
        top_center_z = (bb.ZMin + bb.ZMax) / 2
        top_thickness = bb.ZMax - bb.ZMin
        top_center_x = (bb.XMin + bb.XMax) / 2
        top_center_y = (bb.YMin + bb.YMax) / 2
        
        print(f"Validation - Table top:")
        print(f"  Center: ({top_center_x:.1f}, {top_center_y:.1f}, {top_center_z:.1f}) mm")
        print(f"  Bottom face z-coordinate: {bb.ZMin:.1f} mm (should be near 0)")
        
        # Check if bottom face is at z=0
        if abs(bb.ZMin) > 1.0:  # 1mm tolerance
            print(f"  WARNING: Table top bottom face not at z=0")
    
    # Check legs positioning
    if legs and table_top:
        bb_top = table_top.Shape.BoundBox
        
        # Gather leg positions
        leg_positions = []
        for i, leg in enumerate(legs):
            bb = leg.Shape.BoundBox
            top_z = bb.ZMax
            bottom_z = bb.ZMin
            center_x = (bb.XMin + bb.XMax) / 2
            center_y = (bb.YMin + bb.YMax) / 2
            
            leg_positions.append((center_x, center_y))
            
            print(f"Validation - Leg {i+1}:")
            print(f"  Position: ({center_x:.1f}, {center_y:.1f}) mm")
            print(f"  Top z-coordinate: {top_z:.1f} mm (should be near 0)")
            print(f"  Bottom z-coordinate: {bottom_z:.1f} mm (should touch floor)")
            
            # Check if top of leg connects to bottom of table
            if abs(top_z) > 1.0:  # 1mm tolerance
                print(f"  WARNING: Leg {i+1} top not at z=0")
        
        # Check if legs are at corners
        if len(legs) >= 4:
            # TODO: Add more sophisticated checks to ensure legs are at corners
            pass

# Run validation
validate_table_positioning()
"""
            elif object_type == "chair":
                validation_code = """
# Add validation code to ensure proper positioning
def validate_chair_positioning():
    doc = App.ActiveDocument
    seat = None
    backrest = None
    legs = []
    
    # Identify components
    for obj in doc.Objects:
        if hasattr(obj, "Label"):
            if "seat" in obj.Label.lower():
                seat = obj
            elif "back" in obj.Label.lower():
                backrest = obj
            elif "leg" in obj.Label.lower():
                legs.append(obj)
    
    # Check seat positioning
    if seat:
        bb = seat.Shape.BoundBox
        seat_center_z = (bb.ZMin + bb.ZMax) / 2
        seat_thickness = bb.ZMax - bb.ZMin
        seat_center_x = (bb.XMin + bb.XMax) / 2
        seat_center_y = (bb.YMin + bb.YMax) / 2
        
        print(f"Validation - Seat:")
        print(f"  Center: ({seat_center_x:.1f}, {seat_center_y:.1f}, {seat_center_z:.1f}) mm")
        print(f"  Bottom face z-coordinate: {bb.ZMin:.1f} mm (should be near 0)")
        
        # Check if bottom face is at z=0
        if abs(bb.ZMin) > 1.0:  # 1mm tolerance
            print(f"  WARNING: Seat bottom face not at z=0")
    
    # Check backrest positioning
    if backrest and seat:
        bb_back = backrest.Shape.BoundBox
        bb_seat = seat.Shape.BoundBox
        
        back_min_z = bb_back.ZMin
        
        print(f"Validation - Backrest:")
        print(f"  Bottom z-coordinate: {back_min_z:.1f} mm")
        print(f"  Should connect to seat at approximately {bb_seat.ZMin:.1f} mm")
        
        # Check if backrest connects to seat
        if abs(back_min_z - bb_seat.ZMax) > 1.0 and abs(back_min_z - bb_seat.ZMin) > 1.0:
            print(f"  WARNING: Backrest does not appear to connect to seat")
    
    # Check legs positioning
    if legs and seat:
        bb_seat = seat.Shape.BoundBox
        
        # Gather leg positions
        for i, leg in enumerate(legs):
            bb = leg.Shape.BoundBox
            top_z = bb.ZMax
            bottom_z = bb.ZMin
            
            print(f"Validation - Leg {i+1}:")
            print(f"  Top z-coordinate: {top_z:.1f} mm (should be near 0)")
            print(f"  Bottom z-coordinate: {bottom_z:.1f} mm (should touch floor)")
            
            # Check if top of leg connects to bottom of seat
            if abs(top_z) > 1.0:  # 1mm tolerance
                print(f"  WARNING: Leg {i+1} top not at z=0")

# Run validation
validate_chair_positioning()
"""
            else:
                validation_code = """
# Add generic validation code to check component positioning
def validate_model_positioning():
    doc = App.ActiveDocument
    
    # Report position of all shapes
    for obj in doc.Objects:
        if hasattr(obj, "Shape"):
            bb = obj.Shape.BoundBox
            center_x = (bb.XMin + bb.XMax) / 2
            center_y = (bb.YMin + bb.YMax) / 2
            center_z = (bb.ZMin + bb.ZMax) / 2
            
            print(f"Validation - {obj.Label}:")
            print(f"  Center: ({center_x:.1f}, {center_y:.1f}, {center_z:.1f}) mm")
            print(f"  Z range: {bb.ZMin:.1f} to {bb.ZMax:.1f} mm")

# Run validation
validate_model_positioning()
"""
        
        # Include visual debug code if requested
        visual_debug_code = ""
        if self.visual_debug_checkbox.isChecked():
            visual_debug_code = """
# Add visual debugging indicators
def add_coordinate_system():
    # Create origin indicator
    origin = App.ActiveDocument.addObject("Part::Sphere", "Origin")
    origin.Radius = 5.0
    origin.ViewObject.ShapeColor = (1.0, 0.0, 0.0)  # Red
    
    # Create X axis indicator
    x_axis = App.ActiveDocument.addObject("Part::Cylinder", "X_Axis")
    x_axis.Radius = 2.0
    x_axis.Height = 100.0
    x_axis.Placement = App.Placement(App.Vector(50, 0, 0), App.Rotation(App.Vector(0, 1, 0), 90))
    x_axis.ViewObject.ShapeColor = (1.0, 0.0, 0.0)  # Red
    
    # Create Y axis indicator
    y_axis = App.ActiveDocument.addObject("Part::Cylinder", "Y_Axis")
    y_axis.Radius = 2.0
    y_axis.Height = 100.0
    y_axis.Placement = App.Placement(App.Vector(0, 50, 0), App.Rotation(App.Vector(1, 0, 0), -90))
    y_axis.ViewObject.ShapeColor = (0.0, 1.0, 0.0)  # Green
    
    # Create Z axis indicator
    z_axis = App.ActiveDocument.addObject("Part::Cylinder", "Z_Axis")
    z_axis.Radius = 2.0
    z_axis.Height = 100.0
    z_axis.Placement = App.Placement(App.Vector(0, 0, 50), App.Rotation())
    z_axis.ViewObject.ShapeColor = (0.0, 0.0, 1.0)  # Blue
    
    # Create a ground plane indicator at z=-750 (typical table height)
    ground = App.ActiveDocument.addObject("Part::Box", "GroundPlane")
    ground.Length = 1000.0
    ground.Width = 1000.0
    ground.Height = 1.0
    ground.Placement = App.Placement(App.Vector(-500, -500, -750), App.Rotation())
    ground.ViewObject.ShapeColor = (0.8, 0.8, 0.8)  # Light gray
    ground.ViewObject.Transparency = 80

# Add coordinate system indicators
add_coordinate_system()
"""
        
        user_prompt = f"""Create FreeCAD Python code for: {description}
        
{user_params_text}

{spatial_reasoning_text}

{component_plan_text}

The code must:
1. Import necessary FreeCAD modules
2. Create a new document if needed
3. Create the 3D geometry described
4. Position all components correctly according to the spatial reasoning and component plan
5. Use parametric modeling when appropriate
6. Set dimensions according to provided parameters
7. Use reasonable dimensions for parameters not explicitly provided
8. Add proper colors and appearance
9. Ensure all components have logical real-world positioning
10. Define ALL positions using ABSOLUTE coordinates
11. Be complete and ready to execute

{object_specific_instructions}

Return only the Python code with no explanations or markdown."""

        # Add validation and visual debug code to prompt if needed
        if validation_code:
            user_prompt += "\n\nAdd this validation code at the end of your implementation:\n" + validation_code
            
        if visual_debug_code:
            user_prompt += "\n\nAlso add this visual debug code at the end of your implementation:\n" + visual_debug_code
        
        model = self.model_selector.currentText()
        
        data = {
            "model": model,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "temperature": 0.2,
            "max_tokens": 4000
        }
        
        try:
            # Setting verify=False to bypass SSL verification - use with caution
            response = requests.post(
                API_ENDPOINT,
                headers=headers,
                json=data,
                verify=False,
                timeout=60  # Increased timeout
            )
            
            if response.status_code != 200:
                self.output_log.append(f"API Response Status: {response.status_code}")
                self.output_log.append(f"API Response Content: {response.text}")
                raise Exception(f"API error: {response.text}")
            
            result = response.json()
            code = result["choices"][0]["message"]["content"]
            
            # Remove markdown code blocks if present
            if code.startswith("```python"):
                code = code.replace("```python", "", 1)
                if code.endswith("```"):
                    code = code[:-3]
            
            return code.strip()
            
        except Exception as e:
            self.output_log.append(f"Request error details: {str(e)}")
            raise
    
    def execute_code(self, code: str) -> tuple[bool, str]:
        try:
            # Create a new document if none exists
            if App.ActiveDocument is None:
                App.newDocument("GroqGenerated")
            
            # Execute the code
            exec(code)
            
            # Recompute the document
            App.ActiveDocument.recompute()
            Gui.SendMsgToActiveView("ViewFit")
            
            return True, "Model created successfully"
        except Exception as e:
            return False, f"Failed to execute code: {str(e)}"

    def execute_code_with_debug(self, code: str, object_type: str, user_params: dict = None, 
                               spatial_reasoning: str = None, component_plan: str = None) -> tuple[bool, str]:
        """Execute code with debugging and error feedback"""
        # Store original code for reference
        original_code = code
        
        # Initialize debug information
        debug_info = {
            "attempt": 0,
            "errors": [],
            "object_state": [],
            "execution_log": []
        }
        
        max_attempts = 3  # Maximum number of retry attempts
        
        for attempt in range(max_attempts):
            debug_info["attempt"] = attempt + 1
            
            try:
                # Prepare execution environment
                if App.ActiveDocument is None:
                    App.newDocument("GroqGenerated")
                elif attempt > 0:  # Clear previous attempt if this is a retry
                    doc_name = App.ActiveDocument.Name
                    App.closeDocument(doc_name)
                    App.newDocument("GroqGenerated")
                
                # Create execution tracking
                execution_log = []
                
                # Split code into lines for line-by-line execution
                code_lines = code.split('\n')
                line_num = 0
                
                # Execute code line by line
                while line_num < len(code_lines):
                    current_line = code_lines[line_num].strip()
                    
                    # Skip empty lines and comments
                    if not current_line or current_line.startswith('#'):
                        line_num += 1
                        continue
                    
                    # Find complete statements (handling multi-line statements)
                    statement = current_line
                    while not self.is_complete_statement(statement) and line_num < len(code_lines) - 1:
                        line_num += 1
                        statement += '\n' + code_lines[line_num].strip()
                    
                    # Log the statement being executed
                    execution_log.append(f"Executing: {statement}")
                    
                    try:
                        # Execute the individual statement
                        exec(statement)
                        
                        # Capture object state after significant operations
                        if any(keyword in statement for keyword in ['makeBox', 'makeCylinder', 'extrude', 'cut', 'fuse']):
                            self.capture_object_state(debug_info)
                        
                    except Exception as e:
                        # Capture the specific error
                        error_info = {
                            "line_num": line_num + 1,
                            "code": statement,
                            "error_type": type(e).__name__,
                            "error_msg": str(e),
                            "traceback": traceback.format_exc()
                        }
                        debug_info["errors"].append(error_info)
                        
                        # Log error
                        execution_log.append(f"Error at line {line_num + 1}: {type(e).__name__}: {str(e)}")
                        
                        # Break execution at first error
                        break
                    
                    line_num += 1
                
                # Store execution log
                debug_info["execution_log"] = execution_log
                
                # If we got here without breaking, execution was successful
                if not debug_info["errors"]:
                    # Final recompute
                    App.ActiveDocument.recompute()
                    Gui.SendMsgToActiveView("ViewFit")
                    return True, "Model created successfully"
                
                # If we had errors, try to fix them
                if attempt < max_attempts - 1:  # Don't try to fix on the last attempt
                    # Send debug info to Groq for correction
                    code = self.get_fixed_code_from_groq(
                        original_code, debug_info, object_type, 
                        user_params, spatial_reasoning, component_plan
                    )
                    
                    # Clear errors for next attempt
                    debug_info["errors"] = []
                
            except Exception as e:
                # Catch any other exceptions
                debug_info["errors"].append({
                    "error_type": type(e).__name__,
                    "error_msg": str(e),
                    "traceback": traceback.format_exc()
                })
        
        # If we got here, all attempts failed
        error_summary = self.format_debug_info(debug_info)
        return False, f"Failed to create model after {max_attempts} attempts.\n\n{error_summary}"

    def is_complete_statement(self, code: str) -> bool:
        """Check if a code snippet is a complete Python statement"""
        try:
            compile(code, '<string>', 'exec')
            return True
        except SyntaxError as e:
            if 'unexpected EOF' in str(e):
                return False
            return True  # Other syntax errors mean it's complete but invalid

    def capture_object_state(self, debug_info: dict):
        """Capture the current state of objects in the document"""
        if not App.ActiveDocument:
            return
        
        import time
        objects_info = []
        for obj in App.ActiveDocument.Objects:
            try:
                obj_info = {
                    "name": obj.Name,
                    "type": obj.TypeId,
                    "valid": obj.isValid()
                }
                
                # Capture additional properties based on object type
                if hasattr(obj, "Shape"):
                    obj_info["has_shape"] = True
                    if obj.Shape:
                        obj_info["shape_valid"] = obj.Shape.isValid()
                        obj_info["shape_type"] = obj.Shape.ShapeType
                        
                        # Capture bounding box for position analysis
                        bb = obj.Shape.BoundBox
                        obj_info["bbox"] = {
                            "XMin": bb.XMin, "XMax": bb.XMax,
                            "YMin": bb.YMin, "YMax": bb.YMax,
                            "ZMin": bb.ZMin, "ZMax": bb.ZMax,
                            "Center": [(bb.XMin + bb.XMax)/2, (bb.YMin + bb.YMax)/2, (bb.ZMin + bb.ZMax)/2]
                        }
                    else:
                        obj_info["has_shape"] = False
                
                objects_info.append(obj_info)
            except:
                # Skip objects that cause errors when examined
                pass
        
        debug_info["object_state"].append({
            "timestamp": time.time(),
            "objects": objects_info
        })

    def get_fixed_code_from_groq(self, original_code: str, debug_info: dict, object_type: str,
                                user_params: dict = None, spatial_reasoning: str = None, component_plan: str = None) -> str:
        """Send debug info to Groq and get fixed code"""
        # Format debug info for Groq
        error_context = self.format_debug_info(debug_info)
        
        # Format user parameters if available
        user_params_text = ""
        if user_params and len(user_params) > 0:
            user_params_text = "USER PARAMETERS:\n"
            for name, value in user_params.items():
                user_params_text += f"- {name}: {value}\n"
                
        # Include spatial reasoning if available
        spatial_reasoning_text = ""
        if spatial_reasoning:
            spatial_reasoning_text = f"""SPATIAL REASONING:
{spatial_reasoning}"""
        
        # Include component plan if available
        component_plan_text = ""
        if component_plan:
            component_plan_text = f"""COMPONENT PLAN:
{component_plan}"""
        
        # Object-specific positioning instructions
        object_specific = ""
        if object_type == "table":
            object_specific = """
VERY IMPORTANT POSITIONING REQUIREMENTS:
1. Table top must be positioned with its bottom face at z=0
2. Table top must be centered at (0, 0, table_top_thickness/2)
3. Legs must extend downward from z=0 (they must connect to the bottom of the table top)
4. Legs must be positioned at the corners of the table
5. All positions must use ABSOLUTE coordinates (not relative/incremental)"""
        elif object_type == "chair":
            object_specific = """
VERY IMPORTANT POSITIONING REQUIREMENTS:
1. Seat must be positioned with its bottom face at z=0
2. Seat must be centered at (0, 0, seat_thickness/2)
3. Legs must extend downward from z=0 (they must connect to the bottom of the seat)
4. Backrest must connect to the back edge of the seat and extend upward
5. All positions must use ABSOLUTE coordinates (not relative/incremental)"""
        
        # Create prompt for Groq
        prompt = f"""I tried to create a FreeCAD model with the following Python code, but encountered errors:

ORIGINAL CODE:
```python
{original_code}
```

{user_params_text}
{spatial_reasoning_text}
{component_plan_text}
{object_specific}

EXECUTION DETAILS:
{error_context}

Please fix the code to resolve these errors. Return only the complete corrected code with no explanations or markdown formatting.
The code must:
1. Fix ALL execution errors shown above
2. Ensure components have proper ABSOLUTE positioning
3. Ensure components maintain logical real-world relationships
4. For furniture, ensure supporting elements (legs) properly connect to main elements
5. Maintain the coordinate system where origin (0,0,0) is at the center of the bottom face of the main component
6. Use clear variable names and well-structured code
7. Include the validation and visual debug code if it was in the original

Pay special attention to component positioning and ensure all parts are logically placed."""

        # Send to Groq
        fixed_code = self.send_to_groq(prompt)
        
        # Log the correction attempt
        self.output_log.append(f"Attempt {debug_info['attempt']} failed. Trying with corrected code...")
        
        return fixed_code

    def format_debug_info(self, debug_info: dict) -> str:
        """Format debug info into a readable string for UI display and Groq input"""
        result = []
        
        # Add error information
        if debug_info["errors"]:
            result.append("ERRORS:")
            for i, error in enumerate(debug_info["errors"]):
                result.append(f"Error {i+1}:")
                if "line_num" in error:
                    result.append(f"- Line number: {error['line_num']}")
                if "code" in error:
                    result.append(f"- Code: {error['code']}")
                result.append(f"- Type: {error['error_type']}")
                result.append(f"- Message: {error['error_msg']}")
                # Include only the relevant parts of the traceback
                if "traceback" in error:
                    tb_lines = error["traceback"].split("\n")
                    filtered_tb = [l for l in tb_lines if "File" in l and "<string>" in l]
                    if filtered_tb:
                        result.append("- Traceback:")
                        result.extend([f"  {l}" for l in filtered_tb])
                result.append("")
        
        # Add execution log (last 10 entries to keep it manageable)
        if debug_info["execution_log"]:
            result.append("EXECUTION LOG (last 10 operations):")
            for log in debug_info["execution_log"][-10:]:
                result.append(f"- {log}")
            result.append("")
        
        # Add object state info from the last capture
        if debug_info["object_state"]:
            last_state = debug_info["object_state"][-1]
            result.append("OBJECT STATE:")
            for obj in last_state["objects"]:
                obj_status = "Valid" if obj.get("valid", False) else "Invalid"
                result.append(f"- {obj['name']} ({obj['type']}): {obj_status}")
                
                if "has_shape" in obj:
                    if obj["has_shape"]:
                        shape_status = "Valid" if obj.get("shape_valid", False) else "Invalid"
                        result.append(f"  Shape: {obj.get('shape_type', 'Unknown')} ({shape_status})")
                        
                        # Include bounding box info if available
                        if "bbox" in obj:
                            bb = obj["bbox"]
                            result.append(f"  Position: Center at ({bb['Center'][0]:.1f}, {bb['Center'][1]:.1f}, {bb['Center'][2]:.1f})")
                            result.append(f"  Z Range: {bb['ZMin']:.1f} to {bb['ZMax']:.1f}")
                    else:
                        result.append(f"  Shape: None")
        
        return "\n".join(result)

    def send_to_groq(self, prompt: str) -> str:
        """Send a prompt to the Groq API and get a response"""
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.api_key_input.text()}"
        }
        
        model = self.model_selector.currentText()
        
        data = {
            "model": model,
            "messages": [
                {"role": "system", "content": "You are a CAD code debugging assistant. Fix FreeCAD Python code based on error information."},
                {"role": "user", "content": prompt}
            ],
            "temperature": 0.2,
            "max_tokens": 4000
        }
        
        try:
            # Setting verify=False to bypass SSL verification - use with caution
            response = requests.post(
                API_ENDPOINT,
                headers=headers,
                json=data,
                verify=False,
                timeout=60  # Increased timeout
            )
            
            if response.status_code != 200:
                self.output_log.append(f"API Response Status: {response.status_code}")
                self.output_log.append(f"API Response Content: {response.text}")
                raise Exception(f"API error: {response.text}")
            
            result = response.json()
            code = result["choices"][0]["message"]["content"]
            
            # Remove markdown code blocks if present
            if code.startswith("```python"):
                code = code.replace("```python", "", 1)
                if code.endswith("```"):
                    code = code[:-3]
            
            return code.strip()
            
        except Exception as e:
            self.output_log.append(f"Request error details: {str(e)}")
            raise

# Show the dialog when the macro is run
dialog = LLMToCADDialog()
dialog.exec_()
